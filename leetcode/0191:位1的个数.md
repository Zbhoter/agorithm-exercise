# 题目地址
https://leetcode-cn.com/problems/number-of-1-bits/

# 题目描述：位1的个数

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

例 1：
>输入：00000000000000000000000000001011
>
>输出：3
>
>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
>
>例 2：
>
>输入：00000000000000000000000010000000
>
>输出：1
>
>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
>
>例 3：
>
>输入：11111111111111111111111111111101
>
>输出：31
>
>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


# 解答

方法一：能想到的最简单的方法：将输入的整数除以2，每次都统计其余数为1的个数，直到该整数为0停止。
运行时为 O(logn).
```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res = 0;
        while( n){
            res += n % 2;
            n/=2;
        }
        return res;
    }
};
```

当然，这道题不会这么无趣。

再进一步考虑，对于整数 n 和整数 n-1 来讲，其二进制下的最低位的个数肯定是不相同的。

例如 n = 10 = (1010), n - 1 = 9 = (1001), 二者的最低位不同。

因此，运算 n & ( n - 1) 的结果的二进制表示下最低位肯定为 0. 

循环进行 n & (n - 1) 操作，本质上就是将 n 的二进制下第一个为 1 的位改变为 0, 统计该运算的次数即可。


```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int sum = 0;
        while( n){
            sum++;
            n &= (n-1);
        }
        return sum;
    }
};
```

当然，还能进一步优化。

位运算是一个很有意思的操作。

对于一个整数 n, 如何统计其二进制为 1 的位数？

我们可以用自身统计：先分组，将对应位置上的二进制位更改为每组中 1 个数，合并即可。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225222300722.png)

代码略过，留作思考。
