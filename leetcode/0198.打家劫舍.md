# 题目地址
https://leetcode-cn.com/problems/house-robber/

# 题目描述：打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例：
>例 1:
>
>输入: [1,2,3,1]
>
>输出: 4
>
>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。
>
>例 2:
>
>输入: [2,7,9,3,1]
>
>输出: 12
>
>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。


# 解答

阅读题目之后，可以发现题中存在重叠子问题，此时就要想到动态规划。

从最基本的开始考虑：

当数组中一个元素也没有时，自然会返回 0.

当数组中存在一个元素时，返回该元素即可。

当数组中存在两个元素时，返回二者的较大值即可。

当数组中存在三个元素时，例如 a[0], a[1], a[2], 返回值应该是 max( a[0] + a[2], a[1]).

据此，写出以下代码：

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if( nums.size() == 0)
            return 0;
        if( nums.size() == 1)
            return nums.front();

        vector<int> dp( nums.size(), 0);
        dp[0] = nums[0], dp[1] = nums[1];
        for( int i = 2; i < dp.size(); i++)
            dp[i] = nums[i] + max( dp[i-1] - nums[i-1], dp[i-2]);
        
        return max(dp[dp.size() -1], dp[dp.size()-2]);
    }
};
```

上述代码存在优化的空间。
