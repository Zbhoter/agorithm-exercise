# 题目地址

https://leetcode-cn.com/problems/decode-ways/

# 题目描述：解码方法

一条包含字母 A-Z 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例：
>例 1:
>
>输入: "12"
>
>输出: 2
>
>解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
>
>例 2:
>
>输入: "226"
>
>输出: 3
>
>解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。


# 解答

方法一：递归枚举所有可能出现的情况。

由于做出现了重复计算，该算法在运行时间上可能不尽人意。

代码：
```cpp
class Solution {
public:
    int dfs( string& s, int i){
        if( i == s.size())
            return 1;
        
        int res = 0;
        if( i + 1 < s.size() && s[i] > '0' && (s[i] - '0') * 10 + s[i + 1] - '0' <= 26 && (s[i] - '0') * 10 + s[i + 1] - '0' > 0)
            res += dfs(s, i + 2);
        if( s[i] >= '1' && s[i] <= '9')
            res += dfs( s, i + 1);
        
        return res;
    }
    int numDecodings(string s) {
        return dfs(s, 0);
    }
};
```

方法二：动态规划

动态规划和爬梯子问题比较类似，原理基本一样，但是需要避开一些条件限制。

例如对于字符串 "12321", 它的结果与 "123" 、"1232" 有一定的关系。

假设当前位置上的解为 0.
1. 当最后一位满足条件时（即 s.back() != '0'），例如 "12321" 中最后一位是 '1', 满足条件，它的解需要加上 "1232" 的解；若不满足，例如 "12320" 中的 '0' 便不满足条件，此时不需要加上 "1232" 的解。
2. 当最后两位满足条件时, 例如 "12321" 中后两位是 "21", 满足条件，因此它的解需要加上 "123" 的解；若不满足，例如 "12329" 中后两位为 "29", 不满足条件，此时不需要加上 "123" 中的解。

代码：
```cpp
class Solution {
public:
    int numDecodings(string s) {
        vector<int> record(s.size(), 0);
        for( int i = 0; i < s.size(); i++)
            if( i == 0)
                record[i] = s[0] != '0';
            else if( i == 1){
                if( s[i] != '0')
                    record[i] = record[i-1];
                if( s[i - 1] != '0' && (s[i-1] - '0') * 10 + s[i] - '0' < 27 && (s[i-1] - '0') * 10 + s[i] - '0' > 0)
                    record[i] += 1;    
            }
            else{
                if( s[i] != '0')
                    record[i] = record[i-1];
                if( s[i - 1] != '0' && (s[i-1] - '0') * 10 + s[i] - '0' < 27 && (s[i-1] - '0') * 10 + s[i] - '0' > 0)
                    record[i] += record[i-2];
            }
        
        return record.back();
    }
};
```
