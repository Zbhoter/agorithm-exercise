# 题目地址

https://leetcode-cn.com/problems/gray-code/

# 题目描述：格雷编码

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值**仅有一个位数**的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例:

>例 1:
>
>输入: 2
>
>输出: [0,1,3,2]
>
>解释:
>
>00 - 0
>
>01 - 1
>
>11 - 3
>
>10 - 2
>
>对于给定的 n，其格雷编码序列并不唯一。
>
>例如，[0,2,3,1] 也是一个有效的格雷编码序列。
>
>00 - 0
>
>10 - 2
>
>11 - 3
>
>01 - 1
>
>例 2:
>
>输入: 0
>
>输出: [0]
>
>解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2^n。当 n = 0 时，长度为 2^0 = 1. 因此，当 n = 0 时，其格雷编码序列为 [0]。

# 解答

这道题花费了一下午的时间，不过总算得出一个线性时间的算法：差值法

首先看 n = 0,1,2,3 的情况：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190929173159488.png)

从上图，我们可以看到，不同的 n 之间的元素是存在一定继承关系的。

对于 n = 3 那一行，相邻元素之间的差值为：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190929173754666.png?)

我们可以发现如下规律：
1. n 值变化处（即红线划开的区域），会发生一个 2 的指数的提升（即绿色圆圈标记的差值）。
2. n 值变化处两侧，差值呈互为负数关系，例如 圆圈 2 处两侧，分别为 (1, -1); 圆圈 4 两侧，分别为 (-1, 1), (2,-2),(1,-1). 

再结合下标之间的关系，代码自然也就清晰了。

代码：
```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> res{0};     //当 n = 0 时候;
        
        for( int i = 1, base = 1, count = 2; i < pow(2,n); i++)
            if( i == base)
                res.push_back( res.back() + base), base<<=1, count = 2;
            else
                res.push_back(  res[i - 1] - (res[ i - count] - res[ i - count - 1])), count += 2;
        
        return res;
    }
};
```


当然，还有镜像法、公式法等。
